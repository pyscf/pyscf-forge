#!/usr/bin/env python
# Copyright 2014-2021 The PySCF Developers. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Author: Hong-Zhou Ye <hzyechem@gmail.com>
#

import numpy as np

def autofrag_atom(mol, H2heavy=False):
    ''' Group non-ghost atoms into fragments. Return fragment definitions by
        atom indices

    Args:
        mol (gto.Mole or pbc.gto.Cell):
            PySCF Mole object.
        H2heavy (bool):
            Wether to include H atoms into the fragment of the nearest heavy
            atom (e.g., a CH3 group). Default is False, which means every atom
            defines an individual fragment.
            In case of no heavy atoms (e.g., a H chain), this variable is ignored
            and every H atom defines a fragment.

    Return:
        frag_atmlist (nested list):
            Fragment definition by atom indices. E.g., [[0],[1,5],[2,3,4],...] means
                fragment 1 consists of atom 0
                fragment 2 consists of atom 1 and 5
                fragment 3 consists of atom 2, 3, and 4
                ...
    '''
    if H2heavy:
        get_dist = lambda x,y: ((x[:,None,:]-y)**2.).sum(axis=-1)

        if hasattr(mol, 'lattice_vectors'):  # mol is actually a Cell object
            alat = mol.lattice_vectors()
        else:
            alat = None
        cs = mol.atom_charges()
        rs = mol.atom_coords()
        idx_H = np.where(cs == 1)[0]
        idx_X = np.where(cs > 1)[0]
        if idx_X.size > 0:
            if alat is None:
                d2 = get_dist(rs[idx_H], rs[idx_X])
                H2Xmap = np.argmin(d2, axis=1)
            else:
                d2 = []
                for jx in [-1,0,1]:
                    for jy in [-1,0,1]:
                        for jz in [-1,0,1]:
                            a = np.dot(np.array([jx,jy,jz]), alat)
                            d2.append( get_dist(rs[idx_H], rs[idx_X]+a) )
                d2 = np.hstack(d2)
                H2Xmap = np.argmin(d2, axis=1) % len(idx_X)
            frag_atmlist = [None] * len(idx_X)
            for i,iX in enumerate(idx_X):
                iHs = np.where(H2Xmap==i)[0]
                l = np.asarray(np.concatenate([[iX], idx_H[iHs]]),
                               dtype=int).tolist()
                frag_atmlist[i] = l
        else:   # all-H system
            print('warning: no heavy atom detected in the system; every '
                  'hydrogen atom is treated as a single fragment.')
            frag_atmlist = [[i] for i in idx_H]
    else:
        frag_atmlist = [[i] for i in np.where(mol.atom_charges() > 0)[0]]

    return frag_atmlist

def autofrag_iao(moliao, frag_type='atom', frag_atmlist=None):
    ''' Group IAOs into fragments. Return fragment definitions by IAO indices.

    Args:
        moliao (gto.Mole or pbc.gto.Cell):
            Mole/Cell object generated by `lo.iao.reference_mol`.
        frag_atmlist (nested list):
            Fragment definitions by atom indices. If not provided, `autofrag_atom`
            will be called to generate a `frag_atmlist` using `moliao` with
            `H2heavy` set to False.
        frag_type (str, case insensitive):
            How IAOs are grouped into fragments:
                'atom' (default):
                    All IAOs on an atom define a fragment.
                'shell':
                    Each shell of IAOs on an atom define a fragment.
                    E.g., 3 fragments per carbon atom, 1s, 2s and 2p.
                'shell deep':
                    Shells of IAOs sharing same angular momentum on an atom define
                    a fragment. E.g., 2 fragments per carbon atom, 1s+2s and 2p.
                '1o' or 'orbital':
                    Each IAO defines a fragment. Note that this choice leads
                    to energy not invariant to rotations of a molecule.

    Returns:
        frag_lolist (nested list):
            Fragment definition by IAO indices. E.g., [[0],[1,5],[2,3,4],...] means
                fragment 1 consists of IAO 0
                fragment 2 consists of IAO 1 and 5
                fragment 3 consists of IAO 2, 3, and 4
                ...
    '''
    frag_type = frag_type.lower()
    if frag_type == '1o' or frag_type.startswith('orb'):
        frag_lolist = [[i] for i in range(moliao.nao_nr())]
    elif frag_type.startswith('at'):
        if frag_atmlist is None: frag_atmlist = autofrag_atom(moliao)
        frag_lolist = [np.hstack([range(p0,p1) for (b0,b1,p0,p1) in
                                  moliao.aoslice_by_atom()[atom_ids]]).tolist()
                       for atom_ids in frag_atmlist]
    elif frag_type == 'shell':
        nbas = moliao.nbas
        ao_loc = moliao.ao_loc_nr()
        frag_lolist = [list(range(*ao_loc[i:i+2])) for i in range(nbas)]
    elif frag_type == 'shell deep':
        from pyscf import lib
        nbas = moliao.nbas
        ao_loc = moliao.ao_loc_nr()
        bas_nao = ao_loc[1:] - ao_loc[:-1]
        bas_ls = np.asarray([moliao.bas_angular(i) for i in range(nbas)])
        bas_nao0_sph = 2*bas_ls+1
        bas_nao0_cart = (bas_ls+1)*(bas_ls+2)//2
        if np.all(bas_nao%bas_nao0_sph == 0):
            bas_nao0 = bas_nao0_sph
        elif np.all(bas_nao%bas_nao0_cart == 0):
            bas_nao0 = bas_nao0_cart
        else:
            raise RuntimeError
        frag_lolist = [list(range(p0,p1)) for i in range(nbas) for p0,p1 in
                       lib.prange(*ao_loc[i:i+2],bas_nao0[i])]
    else:
        raise ValueError('Unknown frag_type %s' % (str(frag_type)))
    return frag_lolist

def _matpow(A, p):
    e, u = np.linalg.eigh(A)
    return np.dot(u * e**p, u.T.conj())

def _map_lo_to_frag(mol, orbloc, frag_atmlist, verbose=None):
    r''' Assign input LOs (assumed orthonormal) to fragments using the Lowdin charge.

    For each IAO 'i', a 1D array, [p_1, p_2, ... p_nfrag], is computed, where
        p_ifrag = \sum_{mu on fragment i} ( (s1e^{1/2}*orbloc)[mu,i] )**2.
    '''
    from pyscf.lib import logger
    if verbose is None:
        verbose = mol.verbose
    log = logger.new_logger(mol, verbose)

    if hasattr(mol, 'pbc_intor'):
        s1e = mol.pbc_intor('int1e_ovlp')
    else:
        s1e = mol.intor('int1e_ovlp')
    s1e_sqrt = _matpow(s1e, 0.5)
    plo_ao = np.dot(s1e_sqrt, orbloc)**2.
    aoslice_by_atom = mol.aoslice_nr_by_atom()
    aoind_by_frag = [np.concatenate([range(*aoslice_by_atom[atm][-2:])
                                     for atm in atmlist])
                     for atmlist in frag_atmlist]
    plo_frag = np.array([plo_ao[aoind].sum(axis=0)
                         for aoind in aoind_by_frag]).T
    lo_frag_map = plo_frag.argmax(axis=1)
    nlo, nfrag = plo_frag.shape
    for i in range(nlo):
        log.debug1('LO %d is assigned to fragment %d with charge %.2f',
                   i, lo_frag_map[i], plo_frag[i, lo_frag_map[i]])
        log.debug2('pop by frag:' + ' %.2f'*nfrag, *plo_frag[i])

    frag_lolist = [np.where(lo_frag_map==i)[0] for i in range(nfrag)]
    return frag_lolist

def map_lo_to_frag(mol, orbloc, frag_atmlist, verbose=None):
    if isinstance(orbloc, (list, tuple)) and len(orbloc) == 2:
        frag_lolista = _map_lo_to_frag(mol, orbloc[0], frag_atmlist, verbose=verbose)
        frag_lolistb = _map_lo_to_frag(mol, orbloc[1], frag_atmlist, verbose=verbose)
        assert len(frag_lolista) == len(frag_lolistb)
        frag_lolist = []
        for a, b in zip(frag_lolista, frag_lolistb):
            frag_lolist.append([a, b])
        return frag_lolist
    else:
        return _map_lo_to_frag(mol, orbloc, frag_atmlist, verbose=verbose)

